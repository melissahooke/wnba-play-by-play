---
title: "wnba-shot-charts"
output: pdf_document
---


```{r}
library(tidyverse)
```


```{r}
```


Flip the other end of the court to this side
```{r}
data = read.csv("espn.com/espn-pbp-2020.csv")

data = data %>%
  mutate(xcoord = xcoord*94/100) %>%
  mutate(ycoord = ycoord*50/100)

data %>%  ggplot(aes(x=xcoord,y=ycoord)) + geom_point() + 
  facet_wrap(~EventTeam,nrow=4,ncol=3) + 
  geom_vline(xintercept = 0,col="red") + 
  geom_hline(yintercept = 0,col="red") + 
  geom_hline(yintercept = 50, col="red")


data$xcoord %>% summary()
data$ycoord %>% summary()

data = data %>% mutate(ycoord = ifelse(xcoord>47,50-ycoord,ycoord)) %>% #still need to learn which direction each team is going for over half shots
  mutate(xcoord = ifelse(xcoord>47,94-xcoord,xcoord))

```


```{r,fig.height=7,fig.width=5.5}
data %>%  ggplot(aes(x=xcoord,y=ycoord)) + geom_point() + facet_wrap(~EventTeam,nrow=4,ncol=3) + geom_vline(xintercept = 0,col="red") + geom_hline(yintercept = 0,col="red") + geom_hline(yintercept = 50, col="red")
```


There may still be heaves here from the other side of the court
```{r,fig.height=7,fig.width=5.5}
data %>%  ggplot(aes(x=xcoord,y=ycoord)) + 
  stat_binhex(bins = 25, alpha = 0.9) + 
  facet_wrap(~EventTeam,nrow=4,ncol=3) + 
  scale_fill_gradient(low = "green", high = "red", trans = 'log') +
  theme_bw()
```

```{r}
data$rebound = NA
data$shouldberebound = NA
for (row in 1:(nrow(data)-1)) {
  if (data[row,"ShotOutcome"] == "missed") {
    data[(row+1),"shouldberebound"] = "yes"
    if (grepl("defensive",data[(row+1),"EventDescription"])) {
      data[row,"rebound"] = "defensive"
      data[(row+1),"rebound"] = "defensive"
    }
    if (grepl("offensive",data[(row+1),"EventDescription"])) {
      data[row,"rebound"] = "offensive"
      data[(row+1),"rebound"] = "offensive"
    }
  }
}

data %>% dplyr::select(EventDescription,ShotOutcome,rebound,shouldberebound)

data %>% filter((ShotOutcome=="missed" & is.na(rebound))|(shouldberebound=="yes"& is.na(rebound)))
```
```{r}
data %>% filter(rebound=="defensive") %>% ggplot(aes(x=xcoord,y=ycoord)) + 
  stat_binhex(bins = 25, alpha = 0.9) + 
  #facet_wrap(~EventTeam,nrow=4,ncol=3) + 
  scale_fill_gradient(low = "green", high = "red", trans = 'log') +
  theme_bw()

data %>% filter(rebound=="offensive") %>% ggplot(aes(x=xcoord,y=ycoord)) + 
  stat_binhex(bins = 25, alpha = 0.9) + 
  #facet_wrap(~EventTeam,nrow=4,ncol=3) + 
  scale_fill_gradient(low = "green", high = "red", trans = 'log') +
  theme_bw()
```

```{r}
center_of_rim = (48+15)/12
data = data %>% mutate(shot_distance = sqrt((xcoord-center_of_rim)^2+(ycoord-25)^2))
data = data %>% mutate(shot_location = ifelse(ShotOutcome!="",ifelse(shot_distance < 4, "restricted area",
                                             ifelse(xcoord<19 & ycoord < 33 & ycoord > 17, "paint",
                                                    ifelse(shot_distance > 22.15 | ycoord > 25+22.15 | ycoord < 25-22.15, "three", "midrange"))),NA))

data %>% filter(ShotOutcome!="" & ShotOutcome!="made") %>%
  filter(!is.na(rebound)) %>% group_by(shot_location,rebound) %>% 
  summarize(n=n()) %>% 
  mutate(freq = n / sum(n)) 
```


Smooth using a GP!
```{r}
#covariance function compatible with multidimensional input vectors
cov_fxn = function(xp,xq) {
  #kron.delta = (sum(xp==xq) == length(xp)) #check whether p==q (we don't have to worry about length(xp)!=length(x1))
  cov = sigma2f*exp(-.5*sum((abs(xp-xq)/l)^2)) #+ kron.delta*sigma2n #if you add the noise here, it gets messed up when multiple inputs are the same
  return(cov)
}

k = function(x,x1) {
  K = matrix(NA,nrow=ncol(x),ncol=ncol(x1))
  for (i in 1:ncol(x)){
    for (j in 1:ncol(x1)){
      K[i,j] = cov_fxn(x[,i],x1[,j])
    }
  }
  return(K)
}

#GP function
gp = function(X,y,new_xs,sigma2f,sigma2n,l) {
  n_new = ncol(new_xs)
  L = t(chol(k(X,X)+sigma2n*diag(1,nrow=ncol(X)))) #add the noise here
  alpha = as.matrix(solve(t(L),solve(L,y)))
  #Loop through the test points
  f_star_bar = rep(0,n_new)
  vf = rep(0,n_new)
  vp = rep(0,n_new)
  logpyX = rep(0,n_new)
  for (i in 1:n_new) {
    x_star = as.matrix(new_xs[,i])
    k_star = k(X,x_star)
    f_star_bar[i] = t(k_star) %*% alpha
    v = solve(L,k_star)
    vf[i] = k(x_star,x_star) - t(v) %*% v
    vp[i] = vf[i] + sigma2n
    logpyX[i] = -.5*t(y)%*%alpha - sum(log(diag(L))-n/2*log(2*pi))
  }
  output = list(f_star_bar,vf,vp,logpyX)
  names(output) = c("f_star_bar","vf","vp","logpyX")
  return(output)
}
```

```{r}
temp = data %>% filter(EventTeam=="LV") %>% group_by(xcoord,ycoord) %>% summarize(num = n())
X = temp[,1:2]
X = t(data.frame(lapply(X, scale)))
y = t(temp[,3])

sigma2f = 1
sigma2n = .001
l = .1


breaks = 300
xcoord = seq(0,100,length.out = breaks)
ycoord = seq(0,100,length.out = breaks)
new_xs = t(as.matrix(expand.grid(xcoord,ycoord)))

model = gp(X,y,new_xs,sigma2f,sigma2n,l)
```


```{r}
p = list(xcoord,ycoord)
kriging(temp$xcoord, temp$ycoord, temp$`n()`, model = "spherical", lags = 10, pixels = 100, polygons = p)
```

```{r}
#temp2 = SpatialPointsDataFrame(temp[,1,2],data = temp$num)
names(temp) = c("x","y","num")
autoKrige(num~1,temp)
```
```{r}
data(meuse)
```


```
L = t(chol(k(X,X)+sigma2n*diag(1,nrow=ncol(X)))) #chol() was giving the upper triangular instead of the lower triangular
alpha = as.matrix(solve(t(L),solve(L,y)))

#Loop through the test points
f_star_bar = rep(0,n_new)
vf = rep(0,n_new)
vp = rep(0,n_new)
logpyX = rep(0,n_new)
for (i in 1:n_new) {
  x_star = as.matrix(new_xs[,i])
  k_star = k(X,x_star)
  f_star_bar[i] = t(k_star) %*% alpha
  v = solve(L,k_star)
  vf[i] = k(x_star,x_star) - t(v) %*% v
  vp[i] = vf[i] + sigma2n
  logpyX[i] = -.5*t(y)%*%alpha - sum(log(diag(L))-n/2*log(2*pi))
}
```

